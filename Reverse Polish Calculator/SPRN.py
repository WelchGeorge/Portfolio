# regex library for input handling
import re


# saturated integer values
MAX_INT = 2147483647
MIN_INT = -2147483648

# maximum stack before stack overflow
MAX_STACK = 23

# look-up table for mathematical precedence of operators, larger numbers come earlier.
OPERATOR_PRECEDENCE = {"^": 4, "*": 3, "/": 3, "%": 3, "+": 2, "-": 2}

# list of pseudo-randoms generated by emulated calculator
RANDOMS = [1804289383, 846930886, 1681692777, 1714636915,
1957747793, 424238335, 719885386, 1649760492,
596516649, 1189641421, 1025202362, 1350490027,
783368690, 1102520059, 2044897763, 1967513926,
1365180540, 1540383426, 304089172, 1303455736,
35005211, 521595368]

# rand_index stores current random number position
rand_index = 0

# return a random number from the list and make the 
# current random number the next in the list. loop once at end of list
def get_rand():
  global rand_index
  rand = RANDOMS[rand_index]
  rand_index = (rand_index + 1) % len(RANDOMS)
  return rand


# method to return precedence of passed operator
def get_precedence(operator):
    return OPERATOR_PRECEDENCE[operator]


# data structure with First in, Last out storage
class Stack:
    # list to hold items
    items = []

    # initialize stack with empty stack or with a number of input arguments
    def __init__(self, *items):
        self.items = []
        for item in items:
            self.items.append(item)

    # add item to stack and return item list if stack is less than the maximum stack depth, else print error 
    # statement "Stack overflow." 
    def push(self, item):
        if self.length() < MAX_STACK:
            return self.items.append(item)
        else:
            print("Stack overflow.")

    # remove and return item from top of stack, if stack has no items to remove, underflow error is printed
    def pop(self):
        if len(self.items) > 0:
            return self.items.pop(self.length() - 1)
        else:
            print("Stack underflow.")

    # return top item from stack without altering stack. if there is no top item, return "Stack empty." to be printed.
    def peek(self):
        if self.is_empty():
            return "Stack empty."
        else:
            return self.items[self.length() - 1]

    # return boolean check for whether stack contains items
    def is_empty(self):
        return self.length() == 0

    # iterate through the stack in insertion order and print items with one item per line. if stack is empty print 
    # the minimum integer value. 
    def print_stack(self):
        if self.is_empty():
            print(MIN_INT)
        else:
            for item in self.items:
                print(item)

    # return the length of the stack.
    def length(self):
        return len(self.items)


# First in, First out data structure for use in infix to postfix conversion
class Queue:
    # list to hold items
    items = []

    # initialize queue with empty queue or with a number of input arguments
    def __init__(self, *items):
        self.items = []
        for item in items:
            self.items.append(item)

    # add item to end of queue
    def enqueue(self, item):
        return self.items.append(item)

    # remove and return item from front of queue
    def dequeue(self):
        return self.items.pop(0)

    # return boolean check for if queue contains items.
    def is_empty(self):
        return len(self.items) == 0


# octal numbers are prefaced with a "0"
def is_octal(number):
    return len(number) > 1 and (number[0] == "0" or (number[0] == "-" and number[1] == "0"))


# converts and octal number as a string to a decimal number as a string, maintaining sign.
def handle_octal(octal_string):
    # initialize decimal output
    decimal = 0
    # set a flag to check if the prefacing 0 has been read
    start = False
    # flag if the input is negative
    is_negative = False
    # iterate through each digit in the octal string
    for i in range(0, len(octal_string)):
        digit = octal_string[i]
        # if the input is negative flag is_negative
        if digit == "-":
            is_negative = True
        
        # if the number has started, add the digit to the decimal output. if it is not the last digit, multiply the 
        # output y 8. 
        elif start:
            # return nothing if any digit is not octal
            if int(digit) > 7:
              return "invalid octal"
            decimal += int(digit)
            if i < len(octal_string) - 1:
                decimal *= 8
        # if the starting 0 has been read flag start as true
        elif digit == "0":
            start = True
    # if the number is negative multiply the result by -1
    if is_negative:
        decimal *= -1
    # return the decimal output as a string
    return str(decimal)


# method to limit a given number to the range from MIN_INT to MAX_INT
def handle_saturation(num):
    if num > MAX_INT:
        return MAX_INT
    elif num < MIN_INT:
        return MIN_INT
    else:
        return num


# print errors for trying to raise to a negative power, or trying to divide by 0.
def handle_arithmetic_exceptions(operator, operand):
    if not type(operand) == int:
        if not operand.isnumeric():
            return True
    if int(operand) < 0 and operator == "^":
        print("Negative power.")
        return False
    if int(operand) == 0 and (operator == "/" or operator == "%"):
        print("Divide by 0.")
        return False
    return True


# passed two numeric strings a, b and a binary operator character, evaluate the operation and return the result with 
# saturation applied. 
def operate(a, b, operator):
    value = 0
    if operator == "*":
        value = int(a) * int(b)
    elif operator == "/":
        # use integer division
        value = int(a) // int(b)
    elif operator == "+":
        value = int(a) + int(b)
    elif operator == "-":
        value = int(a) - int(b)
    elif operator == "^":
        value = int(a) ** int(b)
    elif operator == "%":
        value = int(a) % int(b)
    return handle_saturation(value)


# given a string with no whitespace, split the string into numbers and other characters. return a list of numbers and 
# other characters in the order they were in the passed string. 
def split_string(string):
    # initialize empty string to build number
    number = ""
    # initialize empty output list
    string_list = []
    # iterate through the string by character
    for char in string:
        # if the character is numeric, concatenate it to the number string and continue to the next loop cycle
        if re.match("[0-9]", char):
            number += char
            continue
        # else a non numeric character is read
        else:
            # if the number string is not empty, it contains a complete number which is passed to the output list. 
            # number string is reset. 
            if not number == "":
                # if the number is octal, convert it to decimal
                if is_octal(number):
                    number = handle_octal(number)
                if not number == "invalid octal":
                  string_list.append(number)
                number = ""
            # else there is no current number
            else:
                # if the character is a - sign, add it to the number string as it may be a negative number. continue 
                # a new loop. if there is no following number this will be added as a number itself to the list. 
                if char == "-":
                    number += char
                    continue
            # add the current char to the list
            string_list.append(char)
    # if there is a number remaining that has not been added, add it to the output list.
    if not number == "":
        # if the number is octal, convert it to decimal
        if is_octal(number):
            number = handle_octal(number)
        if not number == "invalid octal":
            string_list.append(number)
    # return the output list.
    return string_list


# covert a string of infix (standard maths notation) to rpn using a Shunting-Yard algorithm. return a queue 
# containing the rpn notation tokens. 
def convert_infix_to_rpn(infix):
    # output queue to be returned
    output = Queue()
    # stack to store operators to add to end of queue.
    operators = Stack()
    # split the infix string into tokens, each representing a number or operator
    tokens = split_string(infix)

    # iterate through the tokens
    for token in tokens:
        # if the token is not numeric or an operator, print an error message to screen
        if re.match("[-+*/%^=dr0-9]", token) is None:
            print("Unrecognised operator or operand \"{}\".\n".format(token))
        else:
            # if the token is a string representing a positive or negative number or the equals sign, put the token 
            # in the output. 
            if re.match("-?[0-9]+", token) is not None or token == "=":
                output.enqueue(token)

            # else if the token is not one of the special characters, r and d, then it is an operator
            elif re.match("[rd]", token) is None:
                # while there is a token in the operators stack with greater or equal precedence to the current token
                while not operators.is_empty() and get_precedence(operators.peek()) >= get_precedence(token):
                    # pop a token from the stack and add it to the output
                    output.enqueue(operators.pop())
                # no operator with larger precedence so add token to the stack
                operators.push(token)
            # add r and d tokens directly to the output
            else:
                output.enqueue(token)
    # while there are still operators in the stack pop a token from the operator stack and put it in the output queue
    while not operators.is_empty():
        output.enqueue(operators.pop())
    # return the output queue, now in rpn order.
    return output


def handle_input():
    # take a line of input from the console and remove comments of the form "# comment#"
    ignore_comments = re.sub("# .*#", "", input())
    # also remove comments of the form "# comment"
    ignore_comments = re.sub("#($| .*)", "", ignore_comments)

    # split d tokens 
    handle_d = re.sub("d", " d ", ignore_comments)

    # split the uncommented input into non-whitespace strings
    infix_arr = handle_d.split()

    # initialize output list
    formatted_arr = []

    # iterate through formatted input and convert each item to rpn then append the rpn list to the output list
    for item in infix_arr:
        postfix = convert_infix_to_rpn(item)
        while not postfix.is_empty():
            formatted_arr.append(postfix.dequeue())

    # return the output list
    return formatted_arr


# main calculator function to run the calculator
def calculate():
    # print input prompt
    print("You can now start interacting with the SRPN calculator")
    # create a stack to hold numbers
    stack = Stack()

    # create a loop while the calculator is running
    while True:
        # parse input into rpn notation with each item as a separate token
        tokens = handle_input()

        # iterate through tokens
        for token in tokens:
            # if the token is an operator
            if re.match("^[-+*/%^]$", token) is not None:
                # if the token wouldn't raise an arithmetic exception (/0, %0 or ^-x)
                if handle_arithmetic_exceptions(token, stack.peek()):
                    # if two items can be removed from the stack
                    if stack.length() >= 2:
                        # remove the top two items from the stack
                        b = stack.pop()
                        a = stack.pop()
                        # operate on the two items using the current operator and push the result to th stack
                        stack.push(operate(a, b, token))
                    # there are less than two items so the items can't be removed as the stack would underflow.
                    else:
                        print("Stack underflow.")
            # if the token is an =, print the top value of the stack
            elif token == "=":
                print(stack.peek())
            # if the token is an r, add a random positive integer to the stack
            elif token == "r":
                stack.push(get_rand())
            # if the token is d, print the entire stack to the screen
            elif token == "d":
                stack.print_stack()
            # otherwise the token is a number so push it to the stack
            else:
                stack.push(token)


calculate()
